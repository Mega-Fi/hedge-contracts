{
  "address": "0x3D24b1f8D629e3A415f6CbdD8929321e6949FaFC",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IHegicOperationalTreasury",
          "name": "pool",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "optionIDs",
          "type": "uint256[]"
        }
      ],
      "name": "unlockAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x0ee6b8bc995f29400f9291161d034b48da5dd0cc256edc0b3b1bba1a05c645ab",
  "receipt": {
    "to": null,
    "from": "0xF15968a096Fc8F47650001585d23bEE819b5affb",
    "contractAddress": "0x3D24b1f8D629e3A415f6CbdD8929321e6949FaFC",
    "transactionIndex": 0,
    "gasUsed": "2090818",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xba2f207c2faaf621173beca639cac1f4a40b579b3b3579cfd5303aa12761105b",
    "transactionHash": "0x0ee6b8bc995f29400f9291161d034b48da5dd0cc256edc0b3b1bba1a05c645ab",
    "logs": [],
    "blockNumber": 9018255,
    "cumulativeGasUsed": "815238",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "b38e6f06082a26d255a7484d5f8c9236",
  "metadata": "{\"compiler\":{\"version\":\"0.8.6+commit.11564f7e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IHegicOperationalTreasury\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"optionIDs\",\"type\":\"uint256[]\"}],\"name\":\"unlockAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"0mllwntrmt3\",\"kind\":\"dev\",\"methods\":{\"unlockAll(address,uint256[])\":{\"params\":{\"optionIDs\":\"The array of options*\"}}},\"title\":\"Hegic Protocol hardcore-beta Unlocker Contract\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"unlockAll(address,uint256[])\":{\"notice\":\"Unlocks the array of options.\"}},\"notice\":\"The contract that allows to automatically unlocks an array of options*\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/utils/Unlocker.sol\":\"Unlocker\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xf101e8720213560fab41104d53b3cc7ba0456ef3a98455aa7f022391783144a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xa28007762d9da9db878dd421960c8cb9a10471f47ab5c1b3309bfe48e9e79ff4\",\"license\":\"MIT\"},\"contracts/Interfaces/IOptionsManager.sol\":{\"content\":\"pragma solidity 0.8.6;\\n\\n/**\\n * SPDX-License-Identifier: GPL-3.0-or-later\\n * Hegic\\n * Copyright (C) 2021 Hegic Protocol\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * This program is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n * GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n **/\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/**\\n * @notice The interface for the contract\\n *   that tokenizes options as ERC721.\\n **/\\n\\ninterface IOptionsManager is IERC721 {\\n    /**\\n     * @param holder The option buyer address\\n     **/\\n    function createOptionFor(address holder) external returns (uint256);\\n\\n    /**\\n     * @param tokenId The ERC721 token ID linked to the option\\n     **/\\n    function tokenPool(uint256 tokenId) external returns (address pool);\\n\\n    /**\\n     * @param spender The option buyer address or another address\\n     *   with the granted permission to buy/exercise options on the user's behalf\\n     * @param tokenId The ERC721 token ID linked to the option\\n     **/\\n    function isApprovedOrOwner(address spender, uint256 tokenId)\\n        external\\n        view\\n        returns (bool);\\n}\\n\",\"keccak256\":\"0x8112a4f2f84024d8d97414d17306134350b05e55612125d8b863d0b8892d7156\",\"license\":\"GPL-3.0-or-later\"},\"contracts/Pool/IHegicOperationalTreasury.sol\":{\"content\":\"pragma solidity 0.8.6;\\n\\n/**\\n * SPDX-License-Identifier: GPL-3.0-or-later\\n * Hegic\\n * Copyright (C) 2022 Hegic Protocol\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * This program is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n * GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n **/\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../Interfaces/IOptionsManager.sol\\\";\\n\\ninterface IHegicOperationalTreasury {\\n    enum LockedLiquidityState {Unlocked, Locked}\\n\\n    event Expired(uint256 indexed id);\\n    event Paid(uint256 indexed id, address indexed account, uint256 amount);\\n    event Replenished(uint256 amount);\\n\\n    struct LockedLiquidity {\\n        LockedLiquidityState state;\\n        address strategy;\\n        uint128 amount;\\n        uint128 premium;\\n        uint32 expiration;\\n    }\\n\\n    function manager() external view returns (IOptionsManager);\\n\\n    function token() external view returns (IERC20);\\n\\n    function lockLiquidityFor(\\n        address holder,\\n        uint128 amount,\\n        uint32 expiration\\n    ) external returns (uint256 optionID);\\n\\n    function payOff(\\n        uint256 lockedLiquidityID,\\n        uint256 amount,\\n        address account\\n    ) external;\\n\\n    function lockedByStrategy(address strategy)\\n        external\\n        view\\n        returns (uint256 lockedAmount);\\n\\n    function getStakeAndCoverBalance() external view returns (uint256 balance);\\n\\n    function totalBalance() external view returns (uint256 totalBalance);\\n\\n    function lockedPremium() external view returns (uint256 lockedPremium);\\n\\n    function benchmark() external view returns (uint256 benchmark);\\n\\n    function totalLocked() external view returns (uint256 totalLocked);\\n\\n    /**\\n     * @notice  Used for unlocking\\n     * liquidity after an expiration\\n     * @param lockedLiquidityID The option contract ID\\n     **/\\n    function unlock(uint256 lockedLiquidityID) external;\\n}\\n\",\"keccak256\":\"0x8f7687e7c0631e48b3c842bb452e67fccdc882551d0c35c4ae14c7d1c33b9df7\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/Unlocker.sol\":{\"content\":\"pragma solidity 0.8.6;\\n\\n/**\\n * SPDX-License-Identifier: GPL-3.0-or-later\\n * Hegic\\n * Copyright (C) 2021 Hegic Protocol\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * This program is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n * GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n **/\\n\\nimport \\\"../Pool/IHegicOperationalTreasury.sol\\\";\\n\\n/**\\n * @author 0mllwntrmt3\\n * @title Hegic Protocol hardcore-beta Unlocker Contract\\n * @notice The contract that allows to automatically unlocks an array of options\\n **/\\ncontract Unlocker {\\n    /**\\n     * @notice Unlocks the array of options.\\n     * @param optionIDs The array of options\\n     **/\\n    function unlockAll(\\n        IHegicOperationalTreasury pool,\\n        uint256[] calldata optionIDs\\n    ) external {\\n        uint256 arrayLength = optionIDs.length;\\n        for (uint256 i = 0; i < arrayLength; i++) {\\n            pool.unlock(optionIDs[i]);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x26c46e2066c5de3d082501e8d30cc58ab637a326d655ef0dbeba523078e9467c\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506101ec806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80631dcda34a14610030575b600080fd5b61004361003e3660046100e3565b610045565b005b8060005b818110156100dc57846001600160a01b0316636198e339858584818110610072576100726101a0565b905060200201356040518263ffffffff1660e01b815260040161009791815260200190565b600060405180830381600087803b1580156100b157600080fd5b505af11580156100c5573d6000803e3d6000fd5b5050505080806100d490610177565b915050610049565b5050505050565b6000806000604084860312156100f857600080fd5b83356001600160a01b038116811461010f57600080fd5b9250602084013567ffffffffffffffff8082111561012c57600080fd5b818601915086601f83011261014057600080fd5b81358181111561014f57600080fd5b8760208260051b850101111561016457600080fd5b6020830194508093505050509250925092565b600060001982141561019957634e487b7160e01b600052601160045260246000fd5b5060010190565b634e487b7160e01b600052603260045260246000fdfea26469706673582212204fbe2ef5badc8149d7200b992f00613b4e59a33383fe2b55f7929e5404de98b164736f6c63430008060033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80631dcda34a14610030575b600080fd5b61004361003e3660046100e3565b610045565b005b8060005b818110156100dc57846001600160a01b0316636198e339858584818110610072576100726101a0565b905060200201356040518263ffffffff1660e01b815260040161009791815260200190565b600060405180830381600087803b1580156100b157600080fd5b505af11580156100c5573d6000803e3d6000fd5b5050505080806100d490610177565b915050610049565b5050505050565b6000806000604084860312156100f857600080fd5b83356001600160a01b038116811461010f57600080fd5b9250602084013567ffffffffffffffff8082111561012c57600080fd5b818601915086601f83011261014057600080fd5b81358181111561014f57600080fd5b8760208260051b850101111561016457600080fd5b6020830194508093505050509250925092565b600060001982141561019957634e487b7160e01b600052601160045260246000fd5b5060010190565b634e487b7160e01b600052603260045260246000fdfea26469706673582212204fbe2ef5badc8149d7200b992f00613b4e59a33383fe2b55f7929e5404de98b164736f6c63430008060033",
  "devdoc": {
    "author": "0mllwntrmt3",
    "kind": "dev",
    "methods": {
      "unlockAll(address,uint256[])": {
        "params": {
          "optionIDs": "The array of options*"
        }
      }
    },
    "title": "Hegic Protocol hardcore-beta Unlocker Contract",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "unlockAll(address,uint256[])": {
        "notice": "Unlocks the array of options."
      }
    },
    "notice": "The contract that allows to automatically unlocks an array of options*",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}